"""
LangGraph Mermaid Workflow (Self-Correction Pattern)

Demonstrates the Self-Correction / Reflection pattern for interview:
- Generates code (Mermaid syntax)
- Validates it (Validation Node)
- If invalid, loops back to fix it (Reflection)
- "Loop until valid" reliability pattern

Flow:
START → generate_code → validate_syntax → (conditional)
    → [valid] → END
    → [invalid] → fix_errors → validate_syntax
"""

import re
from typing import Literal

import structlog
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, START, END

from backend.agents.states import MermaidState

logger = structlog.get_logger()


# ============================================================================
# Node Functions
# ============================================================================


async def generate_code_node(state: MermaidState) -> dict:
    """
    Node 1: Generate initial Mermaid code.
    """
    description = state.get("description", "")
    chart_type = state.get("chart_type", "flowchart")
    
    logger.info("generate_code: Generating", type=chart_type)
    
    llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.1)
    
    system_prompt = """You are a Mermaid.js expert.
Generate valid Mermaid syntax for the requested diagram.
Return ONLY the code block, no markdown formatting.

Style guidelines:
- Use dark theme friendly colors
- Keep it simple and clear"""

    messages = [
        SystemMessage(content=system_prompt),
        HumanMessage(content=f"Create a {chart_type} for: {description}")
    ]
    
    response = await llm.ainvoke(messages)
    code = response.content.replace("```mermaid", "").replace("```", "").strip()
    
    return {
        "current_code": code,
        "attempt_count": 1
    }


async def validate_syntax_node(state: MermaidState) -> dict:
    """
    Node 2: Validate the generated Mermaid syntax.
    
    In a real app, this would use a JS runtime or CLI validator.
    Here we simulate validation with regex for interview demo purposes.
    """
    code = state.get("current_code", "")
    logger.info("validate_syntax: Checking code")
    
    errors = []
    
    # Simple validation rules for demo
    if "graph" in code and "-->" not in code:
        pass # Simple graphs might not have arrows, but usually do
        
    # Check for common hallucinated syntax
    if "style" in code and "fill:" not in code and "stroke:" not in code:
        # Invalid style syntax often generated by weaker models
        pass
        
    # Check for balanced brackets (simple check)
    if code.count("{") != code.count("}"):
        errors.append("Unbalanced curly braces")
    if code.count("[") != code.count("]"):
        errors.append("Unbalanced square brackets")
    if code.count("(") != code.count(")"):
        errors.append("Unbalanced parentheses")
    
    # Simulate partial failure for demonstration if code is empty
    if not code:
        errors.append("Empty code generated")
    
    valid = len(errors) == 0
    error_msg = "; ".join(errors) if errors else None
    
    if valid:
        logger.info("validate_syntax: VALID")
        return {
            "validation_error": None,
            "final_code": code,
            "explanation": "Diagram generated successfully and passed validation."
        }
    else:
        logger.warning("validate_syntax: INVALID", errors=error_msg)
        return {
            "validation_error": error_msg
        }


async def fix_errors_node(state: MermaidState) -> dict:
    """
    Node 3: Fix errors based on validation feedback (Reflection).
    """
    code = state.get("current_code", "")
    error = state.get("validation_error", "")
    attempt = state.get("attempt_count", 1) + 1
    
    logger.info("fix_errors: Fixing", attempt=attempt, error=error)
    
    llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.1)
    
    prompt = f"""The following Mermaid code has errors:
    
{code}

Error message: {error}

Please fix the syntax errors and return only the corrected code.
"""

    response = await llm.ainvoke([HumanMessage(content=prompt)])
    fixed_code = response.content.replace("```mermaid", "").replace("```", "").strip()
    
    return {
        "current_code": fixed_code,
        "attempt_count": attempt,
        "validation_error": None # Reset error for next check
    }


# ============================================================================
# Routing Function
# ============================================================================


def route_validation(state: MermaidState) -> Literal["end", "fix"]:
    """
    Route based on validation result.
    
    Input → valid? → End
              ↓
             Fix → (back to validate)
    """
    error = state.get("validation_error")
    attempt = state.get("attempt_count", 1)
    
    if not error:
        return "end"
    
    # Prevent infinite loops
    if attempt >= 3:
        logger.warning("route_validation: Max attempts reached, giving up")
        return "end"
        
    return "fix"


# ============================================================================
# Graph Builder
# ============================================================================


def create_mermaid_graph():
    """
    Build the Mermaid generation graph (Self-Correction).
    """
    builder = StateGraph(MermaidState)
    
    builder.add_node("generate_code", generate_code_node)
    builder.add_node("validate_syntax", validate_syntax_node)
    builder.add_node("fix_errors", fix_errors_node)
    
    builder.add_edge(START, "generate_code")
    builder.add_edge("generate_code", "validate_syntax")
    
    builder.add_conditional_edges(
        "validate_syntax",
        route_validation,
        {
            "end": END,
            "fix": "fix_errors"
        }
    )
    
    # Loop back to validation after fixing
    builder.add_edge("fix_errors", "validate_syntax")
    
    return builder.compile()


# Global graph instance
mermaid_graph = create_mermaid_graph()


# ============================================================================
# Public Interface
# ============================================================================


async def run_mermaid_generation(description: str, chart_type: str = "flowchart") -> dict:
    """
    Run self-correcting mermaid generation.
    """
    initial_state = {
        "description": description,
        "chart_type": chart_type,
        "attempt_count": 0
    }
    
    try:
        result = await mermaid_graph.ainvoke(initial_state)
        
        final_code = result.get("final_code")
        error = result.get("validation_error")
        
        # If still has error after max retries
        if not final_code and error:
             # Return the best effort code but mark as potentially broken
             return {
                 "code": result.get("current_code", ""),
                 "error": f"Failed after {result.get('attempt_count')} attempts: {error}",
                 "success": False
             }
             
        return {
            "code": final_code,
            "explanation": result.get("explanation", ""),
            "success": True
        }
        
    except Exception as e:
        logger.error("run_mermaid_generation: Failed", error=str(e))
        return {"error": str(e), "success": False}
